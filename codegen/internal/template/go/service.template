// Code generated by gf-codegen. DO NOT EDIT.
// 业务逻辑 service
// 生成日期：{{.table.UpdateTime}}
// 生成人：{{.table.FunctionAuthor}}

package service

{{$gjson:=false}}
{{range $index, $column := .table.Columns}}
{{if eq $column.HtmlType "images" "file" "files"}}
{{$gjson = true}}
{{end}}
{{end}}

import (
    "context"
	"database/sql"
    "{{.table.BackendPackage}}{{if .table.SeparatePackage}}/{{.table.GoFileName}}{{end}}/model"
    "{{.table.BackendPackage}}{{if .table.SeparatePackage}}/{{.table.GoFileName}}{{end}}/model/entity"
    "{{.table.BackendPackage}}{{if .table.SeparatePackage}}/{{.table.GoFileName}}{{end}}/service/internal/dao"
    {{if eq .table.TemplateCategory "tree"}}
    "devops.gitlab.zfkunyu.com/cartsee-go/cartx-etl/library"
    {{end}}
	"github.com/gogf/gf/v2/database/gdb"
    {{if $gjson}}
    "github.com/gogf/gf/v2/encoding/gjson"
    {{end}}
    "github.com/gogf/gf/v2/errors/gerror"
    {{if .table.HasVirtualQueries}}
	"devops.gitlab.zfkunyu.com/cartsee-go/cartx-etl/app/common/tools"
    "github.com/gogf/gf/v2/container/gmap"
	{{range $i, $foreignTable := .table.VirtualQueryRelated}}
	service{{$foreignTable.ClassName}} "{{$foreignTable.BackendPackage}}/{{$foreignTable.GoFileName}}/service"
	{{end}}
	{{end}}
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/util/gconv"
)

type I{{.table.ClassName}} interface {
    GetList(ctx context.Context, req *model.{{.table.ClassName}}ListReq) (*model.{{.table.ClassName}}ListRes, error)
    GetInfoById(ctx context.Context, req *model.{{.table.ClassName}}InfoReq) (*model.{{.table.ClassName}}InfoRes, error)
    Create(ctx context.Context, req *model.{{.table.ClassName}}CreateReq) (*model.{{.table.ClassName}}CreateRes, error)
    Update(ctx context.Context, req *model.{{.table.ClassName}}UpdateReq) (*model.{{.table.ClassName}}UpdateRes, error)
    DeleteByIds(ctx context.Context, req *model.{{.table.ClassName}}DeleteReq) (*model.{{.table.ClassName}}DeleteRes, error)
	DoGetOne(ctx context.Context, req *model.{{.table.ClassName}}DoOneReq) (*model.{{.table.ClassName}}Item, error)
	DoGetList(ctx context.Context, req *model.{{.table.ClassName}}DoListReq) (*model.{{.table.ClassName}}ListRes, error)
	DoCreate(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}CreateRes, error)
	DoUpdate(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}UpdateRes, error)
	DoUpsert(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}CreateRes, error)
	DoDelete(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}DeleteRes, error)
    {{range $index,$column:= .table.ListColumns}}
    {{if $column.IsInlineEditable}}
    Change{{$column.GoField}}(ctx context.Context, req *model.{{$.table.ClassName}}Change{{$column.GoField}}Req) (*model.{{$.table.ClassName}}Change{{$column.GoField}}Res, error)
    {{end}}
    {{end}}
    {{if eq .table.TemplateCategory "tree"}}
    // GetChildrenIds 通过ID获取子级ID
    GetChildrenIds(ctx context.Context) (*model.{{$.table.ClassName}}GetChildrenIdsRes, error)
    {{end}}
    GetPkReference(ctx context.Context) *gdb.Model
}

type {{.table.ClassName}}Impl struct {
    {{if .table.IsRpc}}
    model.Unimplemented{{.table.ClassName}}Server
    {{end}}
}

var {{.table.ClassName}} I{{.table.ClassName}} = new({{.table.ClassName}}Impl)

{{$pk:=""}}
{{$pkGoField:=""}}

{{$createdAt:=""}}
{{$createdAtGoField:=""}}

{{range $index, $column := .table.Columns}}
{{if $column.IsPk}}
    {{$pk = $column.Name}}
    {{$pkGoField = $column.GoField}}
{{end}}
{{if eq $column.Name "created_at"}}
    {{$createdAt = $column.Name}}
    {{$createdAtGoField = $column.GoField}}
{{end}}
{{end}}

// GetList 获取列表
func (s *{{.table.ClassName}}Impl) GetList(ctx context.Context, req *model.{{.table.ClassName}}ListReq) (*model.{{.table.ClassName}}ListRes, error) {
	var (
		total int
		page  int
		order string
		list  []*model.{{.table.ClassName}}Item
		err   error
	)
	m := dao.{{.table.ClassName}}.Ctx(ctx).WithAll()
  {{range $index, $column := .table.QueryColumns}}
    {{if not $column.Base.IsVirtual}}
    {{if eq $column.QueryType "LIKE"}}
    if !g.IsEmpty(req.{{$column.GoField}}) {
        m = m.Where(dao.{{$.table.ClassName}}.Columns.{{$column.GoField}}+" like ?", "%"+req.{{$column.GoField}}+"%")
    }
    {{else if eq $column.QueryType "EQ"}}
    if !g.IsEmpty(req.{{$column.GoField}}) {
        m = m.Where(dao.{{$.table.ClassName}}.Columns.{{$column.GoField}}+" = ?", {{if ne $column.FieldConversion ""}}{{$column.FieldConversion}}({{end}}req.{{$column.GoField}}{{if ne $column.FieldConversion ""}}){{end}})
    }
    {{else if eq $column.QueryType "BETWEEN" }}
    if !g.IsEmpty(req.{{$column.GoField}}) && len(req.{{$column.GoField}}) > 0 {
      if !g.IsEmpty(req.{{$column.GoField}}[0]) {
        m = m.Where(dao.{{$.table.ClassName}}.Columns.{{$column.GoField}}+" >= ?", {{if ne $column.FieldConversion ""}}{{$column.FieldConversion}}({{end}}req.{{$column.GoField}}[0]{{if ne $column.FieldConversion ""}}){{end}})
      }
      if len(req.{{$column.GoField}}) > 1 && !g.IsEmpty(req.{{$column.GoField}}[1]) {
        m = m.Where(dao.{{$.table.ClassName}}.Columns.{{$column.GoField}}+" < ?", {{if ne $column.FieldConversion ""}}{{$column.FieldConversion}}({{end}}req.{{$column.GoField}}[1]{{if ne $column.FieldConversion ""}}){{end}})
      }
    }
    {{end}}
    {{end}}
  {{end}}
  {{if .table.HasVirtualQueries}}
	virtualQueryModelMap := gmap.StrAnyMap{}
  {{range $index, $column := .table.QueryColumns}}
    {{if $column.Base.IsVirtual}}
	if !g.IsEmpty(req.{{$column.GoField}}) {
        ref := virtualQueryModelMap.GetOrSet("{{$column.Base.ForeignKeyColumnName}}", service{{$column.Base.ForeignTableClass}}.{{$column.Base.ForeignTableClass}}.GetPkReference(ctx)).(*gdb.Model)
	    {{if eq $column.QueryType "EQ"}}
	    ref = ref.Where("{{$column.Base.ForeignValueColumnName}}", tools.{{$column.Base.ConvertFunc}}(req.{{$column.GoField}}))
	    {{else if eq $column.QueryType "NE"}}
	    ref = ref.WhereNot("{{$column.Base.ForeignValueColumnName}}", tools.{{$column.Base.ConvertFunc}}(req.{{$column.GoField}}))
	    {{else if eq $column.QueryType "GT"}}
	    ref = ref.WhereGT("{{$column.Base.ForeignValueColumnName}}", tools.{{$column.Base.ConvertFunc}}(req.{{$column.GoField}}))
	    {{else if eq $column.QueryType "GTE"}}
	    ref = ref.WhereGTE("{{$column.Base.ForeignValueColumnName}}", tools.{{$column.Base.ConvertFunc}}(req.{{$column.GoField}}))
	    {{else if eq $column.QueryType "LT"}}
	    ref = ref.WhereLT("{{$column.Base.ForeignValueColumnName}}", tools.{{$column.Base.ConvertFunc}}(req.{{$column.GoField}}))
	    {{else if eq $column.QueryType "LTE"}}
	    ref = ref.WhereLTE("{{$column.Base.ForeignValueColumnName}}", tools.{{$column.Base.ConvertFunc}}(req.{{$column.GoField}}))
	    {{else if eq $column.QueryType "LIKE"}}
	    ref = ref.WhereLike("{{$column.Base.ForeignValueColumnName}}", "%"+tools.String(req.{{$column.GoField}})+"%")
	    {{else if eq $column.QueryType "BETWEEN"}}
	    ref = ref.WhereBetween("{{$column.Base.ForeignValueColumnName}}", tools.{{$column.Base.ConvertFunc}}s(req.{{$column.GoField}}))
	    {{end}}
        virtualQueryModelMap.Set("{{$column.Base.ForeignKeyColumnName}}", ref)
	}
    {{end}}
  {{end}}
	for fk, query := range virtualQueryModelMap.Map() {
        m = m.Where(fk + " IN ?", query)
	}
  {{end}}

    total, err = m.Count()
	if err != nil {
		g.Log().Error(ctx, err)
		err = gerror.Wrap(err, "获取总行数失败")
		return nil, err
	}
    {{if ne .table.TemplateCategory "tree"}}
    if req.PageNum == 0 {
        req.PageNum = 1
    }
    page = int(req.PageNum)
    if req.PageSize == 0 {
        req.PageSize = 10
    }
    order = "{{.table.SortColumn}} {{.table.SortType}}"
    if !g.IsEmpty(req.OrderBy) {
        order = req.OrderBy
    }
    var entities []*entity.{{.table.ClassName}}
    err = m.Fields(model.{{.table.ClassName}}Item{}).Page(page, int(req.PageSize)).Order(order).Scan(&entities)
    {{else}}
    order = "{{.table.SortColumn}} {{.table.SortType}}"
    if !g.IsEmpty(req.OrderBy) {
        order = req.OrderBy
    }
    err = m.Fields(model.{{.table.ClassName}}Item{}).Order(order).Scan(&list)
    {{end}}
	if err != nil {
		g.Log().Error(ctx, err)
		err = gerror.Wrap(err, "获取数据失败")
		return nil, err
	}
    return &model.{{.table.ClassName}}ListRes{
    		Total:       uint64(total),
    		CurrentPage: uint32(page),
    		List:        list,
    }, nil
}

// DoGetList 根据查询条件获取记录列表，支持翻页和排序参数，支持查询条件参数类型自动转换，未赋值或或赋值为nil的字段不参与条件查询
func (s *{{.table.ClassName}}Impl) DoGetList(ctx context.Context, req *model.{{.table.ClassName}}DoListReq) (*model.{{.table.ClassName}}ListRes, error) {
	var (
		total int
		page  int
		order string
		list  []*model.{{.table.ClassName}}Item
		err   error
	)
	m := dao.{{.table.ClassName}}.Ctx(ctx).WithAll().Where(req)
	total, err = m.Count()
	if err != nil {
		g.Log().Error(ctx, err)
		err = gerror.Wrap(err, "获取总行数失败")
		return nil, err
	}
	if req.PageNum == 0 {
		req.PageNum = 1
	}
	page = int(req.PageNum)
	if req.PageSize == 0 {
		req.PageSize = 10
	}
    order = "{{.table.SortColumn}} {{.table.SortType}}"
	if !g.IsEmpty(req.OrderBy) {
		order = req.OrderBy
	}
	err = m.Fields(model.{{.table.ClassName}}Item{}).Page(page, int(req.PageSize)).Order(order).Scan(&list)
	if err != nil {
		g.Log().Error(ctx, err)
		err = gerror.Wrap(err, "获取数据失败")
		return nil, err
	}
	return &model.{{.table.ClassName}}ListRes{
		Total:       uint64(total),
		CurrentPage: uint32(page),
		List:        list,
	}, nil
}

// DoGetOne 根据查询条件获取单条数据，支持排序参数，支持查询条件参数类型自动转换，未赋值或或赋值为nil的字段不参与条件查询
func (s *{{.table.ClassName}}Impl) DoGetOne(ctx context.Context, req *model.{{.table.ClassName}}DoOneReq) (*model.{{.table.ClassName}}Item, error) {
	var (
		list  []*model.{{.table.ClassName}}Item
		order string
		err   error
	)
	m := dao.{{.table.ClassName}}.Ctx(ctx).WithAll().Where(req)
	order = "{{.table.SortColumn}} {{.table.SortType}}"
	if !g.IsEmpty(req.OrderBy) {
		order = req.OrderBy
	}
	err = m.Fields(model.{{.table.ClassName}}Item{}).Order(order).Limit(1).Scan(&list)
	if err != nil {
		g.Log().Error(ctx, err)
		err = gerror.Wrap(err, "获取数据失败")
		return nil, err
	}
	if g.IsEmpty(list) || len(list) == 0 {
		return nil, nil
	}
	return list[0], nil
}

// GetInfoById 由Crud API调用。通过id获取
func (s *{{.table.ClassName}}Impl) GetInfoById(ctx context.Context, req *model.{{.table.ClassName}}InfoReq) (*model.{{.table.ClassName}}InfoRes, error) {
    var (
		id   {{.table.PkColumn.GoType}}
		info *model.{{.table.ClassName}}InfoRes
		err  error
	)
	id = req.Id
    if g.IsEmpty(id) {
        err = gerror.New("参数错误")
		g.Log().Error(ctx, err)
        return nil, err
    }
    var data *entity.{{.table.ClassName}}
    err = dao.{{.table.ClassName}}.Ctx(ctx).WithAll().Where(dao.{{.table.ClassName}}.Columns.{{$pkGoField}}, id).Scan(&data)
	if err != nil {
		err = gerror.Wrap(err, "获取信息失败")
		g.Log().Error(ctx, err)
		return nil, err
	}
    if data == nil {
        return nil, nil
    }
    {{range $index, $column := .table.Columns}}
    {{if eq $column.HtmlType "images" "file" "files"}}
    {{$column.HtmlField}}:= ([]*comModel.UpFile)(nil)
    err = gjson.DecodeTo(data.{{$column.GoField}},&{{$column.HtmlField}})
    if err != nil{
		err = gerror.Wrap(err, "获取信息失败")
		g.Log().Error(ctx, err)
        return nil, err
    }
    {{end}}
    {{end}}
    info = &model.{{.table.ClassName}}InfoRes{}
    err = gconv.Struct(data, info)
    if err != nil {
        return nil, err
    }
    return info, nil
}

// Create 由Crud API调用。插入记录，包括 addColumns 中的全量字段，支持对非主键且可为空字段不赋值，未赋值字段将被更新为 NULL 或数据库表指定的DEFAULT
func (s *{{.table.ClassName}}Impl) Create(ctx context.Context, req *model.{{.table.ClassName}}CreateReq) (*model.{{.table.ClassName}}CreateRes, error) {
	var (
		result       sql.Result
		lastInsertId int64
		rowsAffected int64
		err          error
	)
    result, err = dao.{{.table.ClassName}}.Ctx(ctx).Insert(req)
    if err != nil {
		err = gerror.Wrap(err, "插入失败")
		g.Log().Error(ctx, err)
        return nil, err
    }
    lastInsertId, err = result.LastInsertId()
    if err != nil {
		err = gerror.Wrap(err, "插入失败")
		g.Log().Error(ctx, err)
        return nil, err
    }
    rowsAffected, err = result.RowsAffected()
    if err != nil {
		err = gerror.Wrap(err, "插入失败")
		g.Log().Error(ctx, err)
        return nil, err
    }
    return &model.{{.table.ClassName}}CreateRes{
        LastInsertId: lastInsertId,
        RowsAffected: rowsAffected,
    }, nil
}

// DoCreate 插入记录，包括表中所有字段，支持字段类型自动转换，支持对非主键且可为空字段不赋值，未赋值或赋值为nil的字段将被更新为 NULL 或数据库表指定的DEFAULT
func (s *{{.table.ClassName}}Impl) DoCreate(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}CreateRes, error) {
	var (
		result       sql.Result
		lastInsertId int64
		rowsAffected int64
		err          error
	)
    result, err = dao.{{.table.ClassName}}.Ctx(ctx).Insert(req)
    if err != nil {
		err = gerror.Wrap(err, "插入失败")
		g.Log().Error(ctx, err)
        return nil, err
    }
    lastInsertId, err = result.LastInsertId()
    if err != nil {
		err = gerror.Wrap(err, "插入失败")
		g.Log().Error(ctx, err)
        return nil, err
    }
    rowsAffected, err = result.RowsAffected()
    if err != nil {
		err = gerror.Wrap(err, "插入失败")
		g.Log().Error(ctx, err)
        return nil, err
    }
    return &model.{{.table.ClassName}}CreateRes{
        LastInsertId: lastInsertId,
        RowsAffected: rowsAffected,
    }, nil
}

// Update 由Crud API调用。根据主键更新对应记录，包括 editColumns 中的全量字段。注意：本方法慎用，未赋值字段在原记录中的字段值将被更新为 NULL 或数据库表指定的DEFAULT
func (s *{{.table.ClassName}}Impl) Update(ctx context.Context, req *model.{{.table.ClassName}}UpdateReq) (*model.{{.table.ClassName}}UpdateRes, error) {
    {{ $fieldsEx:= concat "dao." $.table.ClassName ".Columns." $pkGoField }}
    {{if IsNotEmpty .table.CreatedAtColumn}}
        {{$fieldsEx = concat $fieldsEx  "," "dao." $.table.ClassName ".Columns." $.table.CreatedAtColumn.GoField}}
    {{end}}
    {{if IsNotEmpty .table.CreatedByColumn}}
        {{$fieldsEx = concat $fieldsEx  "," "dao." $.table.ClassName ".Columns." $.table.CreatedByColumn.GoField}}
    {{end}}
    var (
        result       sql.Result
        rowsAffected int64
        err          error
    )
    result, err = dao.{{.table.ClassName}}.Ctx(ctx).FieldsEx({{$fieldsEx}}).WherePri(req.{{$pkGoField}}).
        Update(req)
    if err != nil {
		err = gerror.Wrap(err, "更新失败")
		g.Log().Error(ctx, err)
		return nil, err
    }
    rowsAffected, err = result.RowsAffected()
    if err != nil {
        return nil, err
    }
    return &model.{{.table.ClassName}}UpdateRes{
        RowsAffected: rowsAffected,
    }, nil
}

// DoUpdate 根据主键更新对应记录，支持字段类型自动转换，支持对非主键字段赋值/不赋值，未赋值或赋值为nil的字段不参与更新（即不会修改原记录的字段值）
func (s *{{.table.ClassName}}Impl) DoUpdate(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}UpdateRes, error) {
    {{ $fieldsEx:= concat "dao." $.table.ClassName ".Columns." $pkGoField }}
    {{if IsNotEmpty .table.CreatedAtColumn}}
        {{$fieldsEx = concat $fieldsEx  "," "dao." $.table.ClassName ".Columns." $.table.CreatedAtColumn.GoField}}
    {{end}}
    {{if IsNotEmpty .table.CreatedByColumn}}
        {{$fieldsEx = concat $fieldsEx  "," "dao." $.table.ClassName ".Columns." $.table.CreatedByColumn.GoField}}
    {{end}}
    var (
        result       sql.Result
        rowsAffected int64
        err          error
    )
    result, err = dao.{{.table.ClassName}}.Ctx(ctx).FieldsEx({{$fieldsEx}}).WherePri(req.{{$pkGoField}}).
        Update(req)
    if err != nil {
		err = gerror.Wrap(err, "更新失败")
		g.Log().Error(ctx, err)
		return nil, err
    }
    rowsAffected, err = result.RowsAffected()
    if err != nil {
        return nil, err
    }
    return &model.{{.table.ClassName}}UpdateRes{
        RowsAffected: rowsAffected,
    }, nil
}

// DoUpsert 根据主键是否存在，插入或更新对应记录，支持字段类型自动转换，支持对非主键字段赋值/不赋值，未赋值或赋值为nil的字段不参与更新（即不会修改原记录的字段值）
func (s *{{.table.ClassName}}Impl) DoUpsert(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}CreateRes, error) {
    var (
        result       sql.Result
		lastInsertId int64
        rowsAffected int64
        err          error
    )
   	result, err = dao.{{.table.ClassName}}.Ctx(ctx).Data(req).Save()
    if err != nil {
        err = gerror.Wrap(err, "插入/更新失败")
        g.Log().Error(ctx, err)
        return nil, err
    }
    lastInsertId, err = result.LastInsertId()
    if err != nil {
        err = gerror.Wrap(err, "插入/更新失败")
        g.Log().Error(ctx, err)
        return nil, err
    }
    rowsAffected, err = result.RowsAffected()
    if err != nil {
        err = gerror.Wrap(err, "插入/更新失败")
        g.Log().Error(ctx, err)
        return nil, err
    }
    return &model.{{.table.ClassName}}CreateRes{
        LastInsertId: lastInsertId,
        RowsAffected: rowsAffected,
    }, nil
}

// DoDelete 根据条件删除表中记录，未赋值或或赋值为nil的字段不参与条件查询
func (s *{{.table.ClassName}}Impl) DoDelete(ctx context.Context, req *model.{{.table.ClassName}}DoReq) (*model.{{.table.ClassName}}DeleteRes, error) {
    {{ $fieldsEx:= concat "dao." $.table.ClassName ".Columns." $pkGoField }}
    {{if IsNotEmpty .table.CreatedAtColumn}}
        {{$fieldsEx = concat $fieldsEx  "," "dao." $.table.ClassName ".Columns." $.table.CreatedAtColumn.GoField}}
    {{end}}
    {{if IsNotEmpty .table.CreatedByColumn}}
        {{$fieldsEx = concat $fieldsEx  "," "dao." $.table.ClassName ".Columns." $.table.CreatedByColumn.GoField}}
    {{end}}
    var (
        result       sql.Result
        rowsAffected int64
        err          error
    )
	result, err = dao.{{.table.ClassName}}.Ctx(ctx).Delete(req)
    if err != nil {
		err = gerror.Wrap(err, "删除失败")
		g.Log().Error(ctx, err)
		return nil, err
    }
    rowsAffected, err = result.RowsAffected()
    if err != nil {
        return nil, err
    }
    return &model.{{.table.ClassName}}DeleteRes{
        RowsAffected: rowsAffected,
    }, nil
}

// DeleteByIds 删除
func (s *{{.table.ClassName}}Impl) DeleteByIds(ctx context.Context, req *model.{{.table.ClassName}}DeleteReq) (*model.{{.table.ClassName}}DeleteRes, error) {
	var (
		ids          []{{.table.PkColumn.GoType}}
		result       sql.Result
		rowsAffected int64
		err          error
	)
	ids = req.Ids
    if len(ids) == 0 {
        err = gerror.New("参数错误")
		g.Log().Error(ctx, err)
        return nil, err
    }
    {{if eq .table.TemplateCategory "tree"}}
    var childrenIdsRes *model.{{.table.ClassName}}GetChildrenIdsRes
    childrenIdsRes, err = s.GetChildrenIds(ctx)
    if err != nil {
		g.Log().Error(ctx, err)
        return nil, err
    }
    ids = childrenIdsRes.Ids
    {{end}}
    result, err = dao.{{.table.ClassName}}.Ctx(ctx).Delete(dao.{{.table.ClassName}}.Columns.{{$pkGoField}}+" in (?)", ids)
    if err != nil {
		err = gerror.Wrap(err, "删除失败")
		g.Log().Error(ctx, err)
		return nil, err
	}
	rowsAffected, err = result.RowsAffected()
	if err != nil {
		err = gerror.Wrap(err, "删除失败")
		g.Log().Error(ctx, err)
		return nil, err
	}
	return &model.{{.table.ClassName}}DeleteRes{
		RowsAffected: rowsAffected,
	}, nil
}

{{range $index,$column:= .table.ListColumns}}
{{if $column.IsInlineEditable}}
// Change{{$column.GoField}} 修改状态
func (s *{{$.table.ClassName}}Impl) Change{{$column.GoField}}(ctx context.Context, req *model.{{$.table.ClassName}}Change{{$column.GoField}}Req) (*model.{{$.table.ClassName}}Change{{$column.GoField}}Res, error) {
    var (
        result       sql.Result
        rowsAffected int64
        err          error
    )
    result, err = dao.{{$.table.ClassName}}.Ctx(ctx).WherePri(req.{{$pkGoField}}).Update(g.Map{
        dao.{{$.table.ClassName}}.Columns.{{$column.GoField}}: req.{{$column.GoField}},
    })
    if err != nil {
        err = gerror.Wrap(err, "修改{{$column.GoField}}失败")
        g.Log().Error(ctx, err)
        return nil, err
    }
    rowsAffected, err = result.RowsAffected()
    if err != nil {
        err = gerror.Wrap(err, "修改{{$column.GoField}}失败")
        g.Log().Error(ctx, err)
        return nil, err
    }
    return &model.{{$.table.ClassName}}Change{{$column.GoField}}Res{
        RowsAffected: rowsAffected,
    }, nil
}
{{end}}
{{end}}

{{if eq .table.TemplateCategory "tree"}}
// GetChildrenIds 通过ID获取子级ID
func (s *{{.table.ClassName}}Impl) GetChildrenIds(ctx context.Context) (*model.{{.table.ClassName}}GetChildrenIdsRes, error) {
    var (
        ids     []{{.table.PkColumn.GoType}}
        allItem *model.{{.table.ClassName}}ListRes
        err     error
    )
    //获取所有
    allItem, err = s.GetList(ctx, &model.{{.table.ClassName}}ListReq{})
    if err != nil {
        err = gerror.Wrap(err, "获取表 {{.table.ClassName}} 中所有数据失败")
        g.Log().Error(ctx, err)
        return nil, err
    }
    list := make(g.List, len(allItem.List))
    for k, info := range allItem.List {
        list[k] = gconv.Map(info)
    }
    for _, id := range ids {
        children := library.FindSonByParentId(list, int(id), "{{.table.TreeParentCode}}", "{{.table.TreeCode}}")
        for _, cid := range children {
            ids = append(ids, gconv.{{.table.PkColumn.GoType | CaseCamel}}(cid["{{.table.TreeCode}}"]))
        }
    }
    return &model.{{.table.ClassName}}GetChildrenIdsRes{Ids: ids}, nil
}
{{end}}

func (s *{{.table.ClassName}}Impl) GetPkReference(ctx context.Context) *gdb.Model {
	return dao.{{.table.ClassName}}.Ctx(ctx).Fields(dao.{{.table.ClassName}}.Columns.{{.table.PkColumn.GoField}})
}
